<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>AR Measurement Tool</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif; /* Using Inter font */
        }
        /* Basic info display */
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px;
            border-radius: 8px; /* Rounded corners */
            z-index: 10; /* Ensure it's above other elements */
        }
        /* Container for AR UI buttons */
        #ar-ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks to pass through to the AR scene by default */
            z-index: 5; /* Below info, above AR content */
        }
        /* Specific styling for buttons to make them interactive */
        #ar-ui-overlay button {
            pointer-events: auto; /* Re-enable pointer events for buttons */
        }
    </style>
</head>
<body>
    <div id="info" class="text-sm md:text-base">Tap on surfaces to place points and measure distances</div>

    <div id="ar-ui-overlay" class="hidden">
        <div class="absolute bottom-4 left-1/2 -translate-x-1/2 flex space-x-4">
            <button id="undoButton" class="p-3 bg-gray-800 hover:bg-gray-700 text-white rounded-full shadow-lg transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                <img src="undo.png" alt="Undo" width="24" height="24" />
            </button>
            <button id="clearButton" class="p-3 bg-gray-800 hover:bg-gray-700 text-white rounded-full shadow-lg transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                <img src="clear.png" alt="Undo" width="24" height="24" />
            </button>
            <button id="triggerClickButton" class="p-3 bg-blue-800 hover:bg-blue-700 text-white rounded-full shadow-lg transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-target">
                    <circle cx="12" cy="12" r="10"/>
                    <circle cx="12" cy="12" r="6"/>
                    <circle cx="12" cy="12" r="2"/>
                </svg>
            </button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js';
        import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.1/examples/jsm/webxr/ARButton.js';
        import { Raycaster, Vector2 } from 'https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js';

        let camera, scene, renderer;
        let reticle;
        const placedPoints = [];
        const placedLines = [];
        const distanceLabels = [];

        let hitTestSource = null;
        let hitTestSourceRequested = false;

        const pointGeometry = new THREE.SphereGeometry(0.01, 16, 16);
        const pointMaterial = new THREE.MeshBasicMaterial({ color: 0x00CC00 });

        // 3D Button variables
        let arClickButton;
        const raycaster = new Raycaster();
        const pointer = new Vector2();

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera();

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            const arUiOverlay = document.getElementById('ar-ui-overlay');
            renderer.xr.addEventListener('sessionstart', () => {
                arUiOverlay.classList.remove('hidden');
                // When AR session starts, make the HTML trigger button invisible
                document.getElementById('triggerClickButton').classList.add('hidden');
                // Add the 3D AR button to the scene
                initARButton();
            });
            renderer.xr.addEventListener('sessionend', () => {
                arUiOverlay.classList.add('hidden');
                // When AR session ends, make the HTML trigger button visible again
                document.getElementById('triggerClickButton').classList.remove('hidden');
                if (arClickButton) {
                    scene.remove(arClickButton);
                    arClickButton = null;
                }
                clearAllMeasurements();
            });

            document.body.appendChild(
                ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] })
            );

            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
            scene.add(light);

            const reticleGeometry = new THREE.RingGeometry(0.05, 0.06, 32).rotateX(-Math.PI / 2);
            const reticleMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
            reticle = new THREE.Mesh(reticleGeometry, reticleMaterial);
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            const dotGeometry = new THREE.SphereGeometry(0.005, 16, 16);
            const dotMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
            const centerDot = new THREE.Mesh(dotGeometry, dotMaterial);
            centerDot.position.set(0, 0, 0);
            reticle.add(centerDot);

            document.getElementById('undoButton').addEventListener('click', undoLastMeasurement);
            document.getElementById('clearButton').addEventListener('click', clearAllMeasurements);

            window.addEventListener('resize', onWindowResize);

            // Event listener for "tapping" in the AR scene
            renderer.domElement.addEventListener('pointerdown', onPointerDownAR);
        }

        function initARButton() {
            const buttonGeometry = new THREE.PlaneGeometry(0.15, 0.05);
            const buttonCanvas = document.createElement('canvas');
            const context = buttonCanvas.getContext('2d');
            const fontSize = 40;
            const padding = 10;
            const text = 'Place';

            context.font = `${fontSize}px Arial`;
            const textMetrics = context.measureText(text);
            buttonCanvas.width = textMetrics.width + padding * 2;
            buttonCanvas.height = fontSize + padding * 2;

            context.fillStyle = '#4a90e2'; // Blue background
            context.fillRect(0, 0, buttonCanvas.width, buttonCanvas.height);
            context.font = `${fontSize}px Arial`;
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, buttonCanvas.width / 2, buttonCanvas.height / 2);

            const buttonTexture = new THREE.CanvasTexture(buttonCanvas);
            const buttonMaterial = new THREE.MeshBasicMaterial({ map: buttonTexture, transparent: true });
            arClickButton = new THREE.Mesh(buttonGeometry, buttonMaterial);
            arClickButton.position.set(0, -0.1, -0.3); // Position in front of the user
            arClickButton.lookAt(camera.position); // Face the camera
            scene.add(arClickButton);
        }

        function onPointerDownAR(event) {
            if (!renderer.xr.isPresenting) return; // Only process if in AR

            // Normalize pointer coordinates
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            const intersects = raycaster.intersectObjects([arClickButton]);

            if (intersects.length > 0) {
                // The 3D button was "tapped"
                placePoint();
            }
        }

        function onWindowResize() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        }

        function createLabelSprite(text) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const fontSize = 60;
            const padding = 20;

            context.font = `${fontSize}px Arial`;
            const textMetrics = context.measureText(text);
            canvas.width = textMetrics.width + padding * 2;
            canvas.height = fontSize + padding * 2;

            context.font = `${fontSize}px Arial`;
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = 'black';
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.needsUpdate = true;

            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);

            const aspectRatio = canvas.width / canvas.height;
            const spriteHeight = 0.05;
            sprite.scale.set(spriteHeight * aspectRatio, spriteHeight, 1);

            return sprite;
        }

        function placePoint() {
            if (reticle.visible) {
                const point = new THREE.Mesh(pointGeometry, pointMaterial);
                point.position.setFromMatrixPosition(reticle.matrix);
                scene.add(point);
                placedPoints.push(point);

                if (placedPoints.length >= 2) {
                    const p1 = placedPoints[placedPoints.length - 2].position;
                    const p2 = placedPoints[placedPoints.length - 1].position;

                    const lineGeo = new THREE.BufferGeometry().setFromPoints([p1, p2]);
                    const lineMat = new THREE.LineBasicMaterial({ color: 0xFF0000, linewidth: 3 });
                    const line = new THREE.Line(lineGeo, lineMat);
                    scene.add(line);
                    placedLines.push(line);

                    const distance = p1.distanceTo(p2);
                    const labelText = `${distance.toFixed(2)} m`;
                    const label = createLabelSprite(labelText);

                    const midpoint = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
                    label.position.copy(midpoint);
                    scene.add(label);
                    distanceLabels.push(label);

                    console.log(`Distance: ${distance.toFixed(2)} meters`);
                }
            }
        }

        function undoLastMeasurement() {
            if (distanceLabels.length > 0) {
                const lastLabel = distanceLabels.pop();
                scene.remove(lastLabel);
                lastLabel.material.map.dispose();
                lastLabel.material.dispose();
            }
            if (placedLines.length > 0) {
                const lastLine = placedLines.pop();
                scene.remove(lastLine);
                lastLine.geometry.dispose();
                lastLine.material.dispose();
            }
            if (placedPoints.length > 0) {
                const lastPoint = placedPoints.pop();
                scene.remove(lastPoint);
                lastPoint.geometry.dispose();
                lastPoint.material.dispose();
            }
        }

        function clearAllMeasurements() {
            distanceLabels.forEach(label => {
                scene.remove(label);
                label.material.map.dispose();
                label.material.dispose();
            });
            distanceLabels.length = 0;

            placedLines.forEach(line => {
                scene.remove(line);
                line.geometry.dispose();
                line.material.dispose();
            });
            placedLines.length = 0;

            placedPoints.forEach(point => {
                scene.remove(point);
                point.geometry.dispose();
                point.material.dispose();
            });
            placedPoints.length = 0;
        }

        function animate() {
            renderer.setAnimationLoop((timestamp, frame) => {
                if (frame) {
                    const referenceSpace = renderer.xr.getReferenceSpace();
                    const session = renderer.xr.getSession();

                    if (!hitTestSourceRequested) {
                        session.requestReferenceSpace('viewer').then((refSpace) => {
                            session.requestHitTestSource({ space: refSpace }).then((source) => {
                                hitTestSource = source;
                            });
                        });
                        hitTestSourceRequested = true;
                    }

                    if (hitTestSource) {
                        const hitTestResults = frame.getHitTestResults(hitTestSource);
                        if (hitTestResults.length > 0) {
                            const hit = hitTestResults[0];
                            const pose = hit.getPose(referenceSpace);

                            reticle.visible = true;
                            reticle.matrix.fromArray(pose.transform.matrix);
                            // Make the 3D button face the user
                            if (arClickButton) {
                                arClickButton.lookAt(camera.position);
                            }
                        } else {
                            reticle.visible = false;
                        }
                    }
                }
                renderer.render(scene, camera);
            });
        }
    </script>
</body>
</html>